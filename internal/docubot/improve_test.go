package docubot

import (
	"github.com/codalotl/codalotl/internal/gocode"
	"github.com/codalotl/codalotl/internal/gocodecontext"
	"github.com/codalotl/codalotl/internal/gocodetesting"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestImproveDocs(t *testing.T) {
	// Original source with a simplistic, slightly inferior doc string.
	code := dedent(`
        // Foo does something.
        func Foo() {}
    `)

	// Improved documentation snippet that we expect the tool to apply.  In a
	// real scenario this would be generated by the LLM; here we return it via
	// our mock conversationalist.
	improvedSnippet := dedentWithBackticks(`
        // Foo does something better.
        func Foo()
    `)

	// First LLM call (generateAndApplyDocs) returns the new documentation
	// snippet; second call (chooseBetterDocsForIdentifiers) votes for option A
	// (the new docs) over option B (the original docs).
	conv := &responsesConversationalist{responses: []string{
		"Here are the documentation snippets:\n\n" + improvedSnippet,
		`{"Foo":{"best":"A","reason":"Clearer"}}`,
	}}

	gocodetesting.WithCode(t, code, func(pkg *gocode.Package) {
		changes, err := ImproveDocs(pkg, []string{"Foo"}, ImproveDocsOptions{
			BaseOptions: BaseOptions{Conversationalist: conv},
		})
		assert.NoError(t, err)

		// Verify the diff captured a single doc change for Foo and that code changed as expected:
		if assert.Len(t, changes, 1) {
			ch := changes[0]
			assert.False(t, ch.IdentifiersChanged)
			assert.Equal(t, []string{"Foo"}, ch.OldIdentifiers)
			assert.Equal(t, []string{"Foo"}, ch.NewIdentifiers)
			assert.NotNil(t, ch.OldSnippet)
			assert.NotNil(t, ch.NewSnippet)
			assert.Contains(t, ch.OldCode, "// Foo does something.")
			assert.Contains(t, ch.NewCode, "// Foo does something better.")
		}

		// Reload the package from disk to observe applied changes.
		pkg, err = pkg.Reload()
		assert.NoError(t, err)

		content := string(pkg.Files["code.go"].Contents)
		assert.Contains(t, content, "// Foo does something better.")
	})
}

func TestChooseBetterDocsForIdentifiers(t *testing.T) {
	// Prepare canned LLM JSON response. Foo prefers option A, Bar prefers option B.
	mockResponse := `{"Foo":{"best":"A","reason":"Clearer description"},"Bar":{"best":"B","reason":"More concise"}}`
	conv := &responsesConversationalist{responses: []string{mockResponse}}

	// Define the two documentation options for each identifier.
	fooA := "// Foo option A\nfunc Foo() {}"
	fooB := "// Foo option B\nfunc Foo() {}"
	barA := "// Bar option A\nfunc Bar() {}"
	barB := "// Bar option B\nfunc Bar() {}"

	choices := []betterDocs{
		{identifier: "Foo", a: fooA, b: fooB},
		{identifier: "Bar", a: barA, b: barB},
	}

	// A minimal, empty context is sufficient: chooseBetterDocsForIdentifiers only
	// needs ctx.Code(), which returns an empty string on a zero-value Context.
	ctx := &gocodecontext.Context{}

	updated, err := chooseBetterDocsForIdentifiers(ctx, choices, ImproveDocsOptions{BaseOptions: BaseOptions{Conversationalist: conv}})
	assert.NoError(t, err)

	// Verify that the best field for each identifier was populated as expected.
	if assert.Len(t, updated, 2) {
		assert.Equal(t, fooA, updated[0].best)
		assert.Equal(t, "Clearer description", updated[0].reason)

		assert.Equal(t, barB, updated[1].best)
		assert.Equal(t, "More concise", updated[1].reason)
	}

	// Ensure the LLM conversation saw both identifiers.
	if assert.Len(t, conv.convs, 1) {
		joined := strings.Join(conv.convs[0].userMessagesText, "\n")
		assert.Contains(t, joined, "Foo")
		assert.Contains(t, joined, "Bar")
	}
}
