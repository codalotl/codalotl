package anthropic

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"strings"
	"time"
)

const (
	defaultBaseURL = "https://api.anthropic.com" // defaultBaseURL is the Anthropic API base URL.
	defaultVersion = "2023-06-01"                // defaultVersion is the required Anthropic API version header value.
)

// Client is a minimal Anthropic Messages API client.
//
// It supports sending a basic text message and returning the assistant's text reply.
type Client struct {
	APIKey  string       // APIKey is the Anthropic API key used for authentication.
	HTTP    *http.Client // HTTP is the HTTP client used to make requests. If nil, a default client with timeout is used.
	BaseURL string       // BaseURL is the Anthropic API base URL. If empty, a default value is used.
	Version string       // Version is the Anthropic API version header value. If empty, a default value is used.
}

// NewClient returns a new Client with the provided API key.
//
// The client uses sane defaults for HTTP timeout, base URL, and version header.
func NewClient(apiKey string) *Client {
	return &Client{
		APIKey:  apiKey,
		HTTP:    &http.Client{Timeout: 180 * time.Second},
		BaseURL: defaultBaseURL,
		Version: defaultVersion,
	}
}

// MessageRequest is the minimal request payload for the Messages API.
//
// Only text content is supported by this minimal client.
type MessageRequest struct {
	Model     string           `json:"model"`
	MaxTokens int              `json:"max_tokens"`
	Messages  []UserMessageRef `json:"messages"`
	System    string           `json:"system,omitempty"`
}

// UserMessageRef represents a single user/assistant message.
//
// For minimal usage, only string content is supported.
type UserMessageRef struct {
	Role    string `json:"role"`
	Content string `json:"content"`
}

// MessageResponse is a minimal subset of the Messages API response.
//
// Use Text() to extract the assistant's text from content blocks.
type MessageResponse struct {
	ID         string         `json:"id"`
	Model      string         `json:"model"`
	Type       string         `json:"type"`
	Content    []ContentBlock `json:"content"`
	StopReason string         `json:"stop_reason,omitempty"` // StopReason indicates why generation stopped, when provided by the API.
	Usage      MessageUsage   `json:"usage"`                 // Usage describes token usage for the request and response.
}

// ContentBlock represents a piece of response content (text-only supported here).
type ContentBlock struct {
	Type string `json:"type"`
	Text string `json:"text,omitempty"`
}

// Text returns the concatenated text from all text content blocks.
func (r *MessageResponse) Text() string {
	var b strings.Builder
	for _, c := range r.Content {
		if c.Type == "text" {
			b.WriteString(c.Text)
		}
	}
	return b.String()
}

// MessageUsage captures token accounting returned by Anthropic.
//
// InputTokens are tokens consumed from the prompt (including system and history). OutputTokens are tokens generated by the model for this response. Cache* fields
// are present when using prompt caching features.
type MessageUsage struct {
	InputTokens              int `json:"input_tokens"`
	OutputTokens             int `json:"output_tokens"`
	CacheCreationInputTokens int `json:"cache_creation_input_tokens,omitempty"`
	CacheReadInputTokens     int `json:"cache_read_input_tokens,omitempty"`
}

// APIError is a minimal Anthropic error structure.
type APIError struct {
	Type  string `json:"type"`
	Error struct {
		Type    string `json:"type"`
		Message string `json:"message"`
	} `json:"error"`
}

// CreateMessage sends a minimal Messages API request and returns the parsed response.
func (c *Client) CreateMessage(ctx context.Context, reqPayload MessageRequest) (*MessageResponse, error) {
	if strings.TrimSpace(c.APIKey) == "" {
		return nil, errors.New("missing API key")
	}

	httpClient := c.HTTP
	if httpClient == nil {
		httpClient = &http.Client{Timeout: 60 * time.Second}
	}

	baseURL := c.BaseURL
	if baseURL == "" {
		baseURL = defaultBaseURL
	}
	version := c.Version
	if version == "" {
		version = defaultVersion
	}

	// Build request body.
	bodyBytes, err := json.Marshal(reqPayload)
	if err != nil {
		return nil, fmt.Errorf("marshal request: %w", err)
	}

	// Construct HTTP request.
	url := strings.TrimRight(baseURL, "/") + "/v1/messages"
	httpReq, err := http.NewRequestWithContext(ctx, http.MethodPost, url, bytes.NewReader(bodyBytes))
	if err != nil {
		return nil, fmt.Errorf("new request: %w", err)
	}
	httpReq.Header.Set("content-type", "application/json")
	httpReq.Header.Set("x-api-key", c.APIKey)
	httpReq.Header.Set("anthropic-version", version)

	// Execute.
	httpResp, err := httpClient.Do(httpReq)
	if err != nil {
		return nil, fmt.Errorf("do request: %w", err)
	}
	defer httpResp.Body.Close()

	respBody, err := io.ReadAll(httpResp.Body)
	if err != nil {
		return nil, fmt.Errorf("read body: %w", err)
	}

	if httpResp.StatusCode < 200 || httpResp.StatusCode >= 300 {
		// Try to decode structured error first.
		var apiErr APIError
		if err := json.Unmarshal(respBody, &apiErr); err == nil && apiErr.Error.Message != "" {
			return nil, fmt.Errorf("anthropic error (%s): %s", apiErr.Error.Type, apiErr.Error.Message)
		}
		return nil, fmt.Errorf("anthropic error: status %d: %s", httpResp.StatusCode, strings.TrimSpace(string(respBody)))
	}

	var out MessageResponse
	if err := json.Unmarshal(respBody, &out); err != nil {
		return nil, fmt.Errorf("unmarshal response: %w", err)
	}
	return &out, nil
}
